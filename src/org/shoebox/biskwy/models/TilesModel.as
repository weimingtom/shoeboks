/**  HomeMade by shoe[box]   Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are  met:  * Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.    * Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.    * Neither the name of shoe[box] nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/package org.shoebox.biskwy.models {	import fl.data.DataProvider;	import org.shoebox.biskwy.apps.TilesApp;	import org.shoebox.biskwy.commands.CommandProgress;	import org.shoebox.biskwy.commands.map.CMDMapFill;	import org.shoebox.biskwy.core.Database;	import org.shoebox.biskwy.core.Facade;	import org.shoebox.biskwy.events.TileEvent;	import org.shoebox.biskwy.services.SCats;	import org.shoebox.biskwy.services.SImportTile;	import org.shoebox.biskwy.services.STilePreloader;	import org.shoebox.biskwy.services.assets.STiles;	import org.shoebox.events.EventCentral;	import org.shoebox.patterns.commands.events.CommandBatchProgressEvent;	import org.shoebox.patterns.commands.events.CommandEvents;	import org.shoebox.patterns.mvc.abstracts.AModel;	import org.shoebox.patterns.mvc.interfaces.IModel;	import org.shoebox.patterns.service.ServiceBatch;	import org.shoebox.patterns.service.ServiceEvent;	import org.shoebox.patterns.service.ServiceFactory;	import org.shoebox.utils.logger.Logger;	import flash.events.Event;	import flash.events.SQLErrorEvent;	import flash.filesystem.File;	/**	 * org.shoebox.biskwy.models.TilesModel	* @author shoebox	*/	public class TilesModel extends AModel implements IModel{				protected var _aFILES			: Array;		protected var _oBATCH			: ServiceBatch;		protected var _oDPCATS			: DataProvider;		protected var _oBASE			: Database;		protected var _oSERVICE		: STiles;		protected var _oSERVICE_CAST		: SCats;		protected var _sCAT			: String;		protected var _oIMPORT			: SImportTile;		protected var _uLENGTH			: uint;		protected var _uSELECTION		: uint = 0;				// -------o constructor					public function TilesModel() : void {				_oBASE = Database.getInstance();			}		// -------o public						/**			* Model initialization			* 			* @public			* @param	e : optional event (Event) 			* @return	void			*/			final override public function initialize(e : Event = null ) : void {				Facade.getInstance().freeze();				_oBASE = Database.getInstance();						_getCats();			}									/**			* Model cancel			* 			* @public			* @param	e : optional event (Event) 			* @return	void			*/			final override public function cancel(e:Event = null) : void {									}						/**			* Importing a new media in to the list			* 			* @public			* @param	o : file to be imported	(File) 			* @return	void			*/			public function importFile( o : File ) : void {				if(!_oBATCH)					_oBATCH = new ServiceBatch();					_oBATCH.addService(SImportTile , {file : o});							}						/**			* Launch the import			* 			* @public			* @return	void			*/			public function launchImport() : void {				_oBATCH.addEventListener( CommandEvents.COMPLETE , _filter , false , 10 , true );				_oBATCH.call();			}						/**			* Updating the database			* 			* @public			* @return	void			*/			public function dbUpdate() : void {							}						/**			* get length function			* @public			* @param 			* @return			*/			public function get length() : uint {				return _uLENGTH;						}						/**			* Getting the files list			* 			* @public			* @return	file list (Array)			*/			public function get files() : Array {				return _aFILES;			}						/**			* Getting the selected object			* 			* @public			* @return	selected file (Object)			*/			public function get selected() : Object {				return _aFILES[_uSELECTION];			}						/**			* Set the selected tile ID			* 			* @public			* @param 	u : selected tile ID (uint)			* @return	void			*/			public function set selectedID( u : uint) : void {				//trc('set selected ::: '+u);				_uSELECTION = u;								var 	oEVENT : TileEvent = new TileEvent( TileEvent.SELECTION);					oEVENT.tileID = u;					oEVENT.tileDESC = _aFILES[_uSELECTION];				EventCentral.getInstance().dispatchEvent( oEVENT );			}						/**			* Get the selected tileID			* 			* @public			* @return	tileID	(uint)			*/			public function get selectedID() : uint {				return _uSELECTION;			}						/**			* Get the combobox categories list dataprovidr			* 			* @public			* @return	dataprovider (DataProvider)			*/			public function get cats() : DataProvider {				return _oDPCATS;			}						/**			* Filtering the tiles list by category			* 			* @public			* @param	sCAT : the category to be filtered (String) 			* @return	void			*/			public function filter( sCAT : String ) : void {				_sCAT = sCAT;				_filter();							}						/**			* Get a tile desc by his ID			* @public			* @param 	u : tileID 	(uint)			* @return	tile desc 	(Object)			*/			public function getTileByID( u : uint ) : Object {				//getTileByID								var i : int = 0;				for( i ; i < length ; i++)					if(_aFILES[i].id==u)						return _aFILES[i];								return null;			}					// -------o protected									/**			* Get the categories list by calling the <code>SCats</code> service			*			* @return void			*/			protected function _getCats( e : Event = null ) : void {								_oSERVICE_CAST = ServiceFactory.getService(SCats) as SCats;				_oSERVICE_CAST.addEventListener(ServiceEvent.ON_DATAS , 	_onCats , false , 10 , true);				_oSERVICE_CAST.call();			}						/**			* When the categories list is received			*			* @param 	e : service response event (ServiceEvent)			* @return	void			*/			protected function _onCats( e : ServiceEvent ) : void {				trace('TilesModel ::: onCats');				var aCATS:Array = e.datas as Array;								_oDPCATS = new DataProvider();				_oDPCATS.addItem({label:'All'});								var o : Object = {};				for each( o in aCATS)					_oDPCATS.addItem({label : o.cat});								if(e.type == ServiceEvent.ON_DATAS){					e.target.removeEventListener(ServiceEvent.ON_DATAS , _onCats , false);					_getTiles();				}							}							/**			* Get the tiles list by calling the <code>STiles</code> service			*			* @param 	e : optional service event (ServiceEvent)			* @return	void			*/			protected function _getTiles( e : ServiceEvent = null ) : void {				trace('TilesModel ::: getTiles');				_oSERVICE = ServiceFactory.getService(STiles) as STiles;				_oSERVICE.addEventListener(ServiceEvent.ON_DATAS , _onResults , false , 10 , true);				_oSERVICE.addEventListener(ServiceEvent.ON_REFRESH, _onResults , false , 10 , true);				_oSERVICE.call();							}						/**			* When the tiles list is received			*			* @param 	e : service response event (ServiceEvent)			* @return	void			*/			protected function _onResults( e : ServiceEvent ) : void {				trace('TilesModel ::: onResults');								_aFILES = e.datas;				_uLENGTH = (_aFILES) ? _aFILES.length : 0;								var 	oBATCH : ServiceBatch = new ServiceBatch();								var o : Object;				for each( o in _aFILES )					oBATCH.addService( STilePreloader , { datas : o } );					oBATCH.addEventListener( Event.COMPLETE , _onBatchComplete , false , 10 , true );					oBATCH.addEventListener( CommandBatchProgressEvent.PROGRESS , _onProgress , false , 10 , true);					oBATCH.call();			}						/**			* 			*			* @param 			* @return			*/			final protected function _onBatchComplete( e : Event ) : void {				trc('onBatchComplete ::: '+e);				if( CommandProgress.getInstance().isRunning )					CommandProgress.getInstance().cancel();									Facade.getInstance().unfreeze();				update(TilesApp.ON_DATAS);			}						/**			* When an sql error occured			*			* @param 	e : error event (SQLErrorEvent)			* @return	void			*/			protected function _onError(e:SQLErrorEvent) : void {				trc('onError ::: '+e);			}						/**			* Updating the tiles tiles list by using a filter and by calling the <code>STiles</code> service			*			* @param 	e : optional command event (CommandsEvents)			* @return	void			*/			protected function _filter( e : CommandEvents = null ) : void {				_oSERVICE = ServiceFactory.getService(STiles) as STiles;				_oSERVICE.filter = _sCAT;				_oSERVICE.addEventListener(ServiceEvent.ON_DATAS , _onResults , false , 10 , true);				_oSERVICE.call();			}						/**			* 			*			* @param 			* @return			*/			protected function _onProgress ( e : CommandBatchProgressEvent ) : void {				CommandProgress.getInstance().setProgress( (e.position / e.length) * 100 , (e.actualCommand as CMDMapFill).path);			}					// -------o misc			public static function trc(...args : *) : void {				Logger.log(TilesModel, args);			}	}}