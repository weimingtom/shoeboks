/**  HomeMade by shoe[box]   Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are  met:  * Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.    * Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.    * Neither the name of shoe[box] nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/package org.shoebox.biskwy.models.tools {	import flash.net.FileFilter;
	import org.shoebox.biskwy.core.variables.CurrentMapLayers;	import org.shoebox.biskwy.core.variables.LastFile;	import org.shoebox.biskwy.data.LayerItem;	import org.shoebox.biskwy.items.tools.MapLayerItem;	import org.shoebox.biskwy.views.tools.VEditMap;	import org.shoebox.patterns.factory.Factory;	import org.shoebox.patterns.mvc.abstracts.AModel;	import org.shoebox.patterns.mvc.interfaces.IModel;	import org.shoebox.utils.Relegate;	import org.shoebox.utils.display.STAGEINSTANCE;	import org.shoebox.utils.logger.Logger;	import flash.display.Loader;	import flash.events.Event;	import flash.filesystem.*;
	import flash.geom.Point;
	import flash.utils.ByteArray;	/**	 * MEditMap model class 	* 	* org.shoebox.biskwy.models.tools.MEditMap	* @author shoebox	*/	public class MEditMap extends AModel implements IModel {				protected var _oFILE			:File;		protected var _oCURRENTLAYER		:MapLayerItem;		protected var _sTMP			:String;		protected var _oXML			:XML;				// -------o constructor					/**			* Constructor of the model class			*			* @public			* @return	void			*/			public function MEditMap() : void {									_oXML = <root>			      					<entry label = "INFOS" type = "title" prop='infottl'/>			      					<entry label = 'Name' 			prop='layerName' 	type = "string" value = "" />			      					<entry label = 'X decal'		prop='decalX' 	type = "number" value = "0"  min = "-1500"  max = "1500"/>			      					<entry label = 'Y decal'	 	prop='decalY' 	type = "number" value = "0"  min = "-1500"  max = "1500"/>			      								      					<entry label = "PARALLAX LAYER" 	type = "title" prop='infottl'/>			      								      					<entry label = 'Is parallax' 		prop='bParallax' type = "boolean" value = "false" />			      					<entry label = 'Is tileable' 		prop='bTileable' type = "boolean" value = "false" />			      					<entry label = 'Speed'	 		prop='iSpeed' 	type = "number" value = "0"  min = "-1500"  max = "1500"/>			      					      		</root>;			}		// -------o public						/**			* Model initialization 			* 			* @public			* @param	e : optional initialization event (Event) 			* @return	void			*/			final override public function initialize( e : Event = null ) : void {				trc('intialize');				Relegate.afterFrame( STAGEINSTANCE , _onFrames , 2 );							}									/**			* When the model and the triad is canceled			* 			* @public			* @param	e : optional cancel event 	( Event ) 			* @return	void			*/			final override public function cancel(e:Event = null) : void {									}						/**			* Getter the XML descriptor for the <code>PropsPanel</code> of the specified layer			*  			* @public			* @param	i : layer id 			( int ) 			* @return	layer xml descriptor		( XML )			*/			final public function getLayerDesc() : XML {				return _oXML;			}						/**			* Return the number of layers contains in to the map			* 			* @public			* @return	length 				( uint )			*/			final public function get layerLength() : uint {				return CurrentMapLayers.length;			}						/**			* Return the name of the specified layer ID			* 			* @public			* @param	i : layer id 			( int ) 			* @return	void			*/			final public function getLayerNameByID( i : int ) : String {				return CurrentMapLayers[i].layerName;			}						/**			* Return the layer media by is ID			* 			* @public			* @param	i : Layer ID		( int ) 			* @return	layer media			( ByteArray )			*/			final public function getLayerBitmap( i : int ) : ByteArray {				return CurrentMapLayers[i].media;			}						/**			* Get a layer by is ID			* 			* @public			* @param	i : layer ID		( int ) 			* @return	layer 			( LayerItem )			*/			final public function getLayerRef( i : int ) : LayerItem {				return CurrentMapLayers[i];			}						/**			* Getter of the layer type ( Game layer or not )			* 			* @public			* @return	is game layer ( Boolean )			*/			final public function isGameLayer( i :int ) : Boolean {				return CurrentMapLayers[i].isGameLayer;			}						/**			* Create a new layer with the specified name			* 			* @public			* @param	s : Layer name - Must be unique (String) 			* @return	void			*/			final public function createLayer( s : String ) : void {				trc('createLayer ::: '+s);				_createLayer(s);			}						/**			* getLayerDecal function			* @public			* @param 			* @return			*/			final public function getLayerDecal( i : int = -1 ) : Point {				if( i == -1 )					return new Point( _oCURRENTLAYER.ref.decalX , _oCURRENTLAYER.ref.decalY );				else 					return new Point( CurrentMapLayers[i].decalX , CurrentMapLayers[i].decalY );			}			/**			* Edit the specified layer			* 			* @public			* @param	o : Layer to be edited		(MapLayerItem) 			* @return	void			*/			final public function edit( o : MapLayerItem ) : void {				trc('edit ::: '+o);				_oCURRENTLAYER = o;				(view as VEditMap).setSelected( o );				update( Event.SELECT );				update( Event.CHANGE );			}			/**			* Move a layer by the specified amount in to the list			* 			* @public			* @param	iMOV : amount to move 	(int) 			* @return	void			*/			final public function moveLayer( iMOV : int ) : void {				trc('moveLayer ::: '+iMOV );								var oREF:LayerItem = _oCURRENTLAYER.ref;								var iPOS : int = CurrentMapLayers.indexOf( oREF );								//					if( iMOV < 0 && iPOS == 0 )						return;											if( iMOV > 0 && iPOS == (CurrentMapLayers.length - 1))						return;								//					CurrentMapLayers.splice( iPOS , 1 );					CurrentMapLayers.splice( iPOS + iMOV , 0 , oREF );					update( Event.CHANGE );			}						/**			* delLayer function			* @public			* @param 			* @return			*/			final public function delLayer() : void {				trc('delLayer');				CurrentMapLayers.splice( CurrentMapLayers.indexOf( _oCURRENTLAYER.ref ) , 1 );				update( Event.CHANGE );			}						/**			* Return the <code>PropsPanel</code> dataprovider xml			* 			* @public			* @return	dataprovider		(XML)			*/			final public function get layerDesc() : XML {				_oXML..entry.( @prop == 'layerName' )[0].@value = _oCURRENTLAYER.ref.layerName;				_oXML..entry.( @prop == 'decalX' )[0].@value = _oCURRENTLAYER.ref.decalX;				_oXML..entry.( @prop == 'decalY' )[0].@value = _oCURRENTLAYER.ref.decalY;				_oXML..entry.( @prop == 'bParallax' )[0].@value = _oCURRENTLAYER.ref.bParallax;				_oXML..entry.( @prop == 'bTileable' )[0].@value = _oCURRENTLAYER.ref.bTileable;				_oXML..entry.( @prop == 'iSpeed' )[0].@value = _oCURRENTLAYER.ref.iSpeed;				return _oXML;			}						/**			* When a propery of the <code>PropsPanel</code> is changed			* 			* @public			* @param  	sPropName : Name of the modified property	( String )			* @return	void			*/			final public function propsChange( sPropName : String ) : void {				trace('propsChange ::: ' + sPropName);				if( _oCURRENTLAYER.ref.hasOwnProperty(sPropName) ) {					_oCURRENTLAYER.ref[sPropName] = (view as VEditMap).oPropPanel.dataProvider..entry.( @prop == sPropName )[0].@value;					update( Event.CHANGE );				}			}		// -------o protected						/**			* Temporary after frame listener function			*			* @param 	e : optional event (Event)			* @return	void			*/			final protected function _onFrames( e : Event = null ) : void {				update( Event.CHANGE );			}						/**			* Create a new layer			*			* @param 	s : layer name 		(String)			* @return	void			*/			final protected function _createLayer( s : String ) : void {				trc('_createLayer :: '+s);
				_sTMP = s;
				_oFILE = File.documentsDirectory;				_oFILE.addEventListener( Event.SELECT , _onBrowsed , false , 10 , true);				_oFILE.browseForOpen( 'Select the layer media file' , [new FileFilter('Media Files','*.swf;*.png;*.bmp')] );							}						/**			* When the layer media file is selected 			*			* @param 			* @return			*/			final protected function _onBrowsed( e : Event ) : void {								LastFile = (e.target as File).parent;								var 	oMEDIA : ByteArray = new ByteArray();								var 	oSTREAM : FileStream = new FileStream();					oSTREAM.open( e.target as File , FileMode.READ );					oSTREAM.readBytes( oMEDIA );									oSTREAM.close();									var	oLOADER : Loader = new Loader();					oLOADER.loadBytes( oMEDIA );								CurrentMapLayers.push( Factory.build( LayerItem ,	{														layerName : _sTMP,														media : oMEDIA ,														isGameLayer : false,														loaderRef : oLOADER													} ));				update( Event.CHANGE );			}						// -------o misc			public static function trc(...args : *) : void {				Logger.log(MEditMap, args);			}	}}